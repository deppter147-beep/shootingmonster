<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bow Defense - 0.5s Speed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; color: white; user-select: none; }
        #gameContainer { position: relative; width: 100vw; height: 100vh; }
        canvas { background-color: #2b2b2b; cursor: crosshair; }

        /* UI Panel */
        .ui-panel { position: absolute; background: rgba(0, 0, 0, 0.85); border: 1px solid #555; padding: 10px; border-radius: 8px; pointer-events: none; z-index: 10; }
        
        #centerNotification {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; width: 100%; pointer-events: none; z-index: 50;
        }
        #levelTitle { font-size: 60px; font-weight: bold; color: #ffd700; text-shadow: 0 0 20px #ff0000; margin: 0; display: none; }
        #waveTitle { font-size: 30px; color: #fff; margin-top: 10px; display: none; }

        #statsPanel { top: 20px; left: 20px; width: 260px; }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 13px; color: #ccc; }
        .stat-val { color: #ffd700; font-weight: bold; }
        .special-stat { color: #00ffff; }

        #resourcePanel { top: 90px; right: 20px; text-align: right; border: 2px solid #00ffff; background: rgba(0, 50, 50, 0.8); }
        .soul-count { font-size: 32px; color: #00ffff; font-weight: bold; text-shadow: 0 0 10px #00ffff; }

        #baseHealthContainer {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            width: 500px; height: 25px; background: #333; border: 2px solid #fff; border-radius: 15px; overflow: hidden; z-index: 20;
        }
        #baseHealthBar { width: 100%; height: 100%; background: linear-gradient(90deg, #d32f2f, #f44336); transition: width 0.2s; }
        #baseHealthText { position: absolute; width: 100%; text-align: center; top: 2px; font-size: 14px; font-weight: bold; text-shadow: 1px 1px 2px black; z-index: 21; }

        #skillBarContainer {
            position: absolute; bottom: 20px; right: 20px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 5px; pointer-events: auto; z-index: 20;
        }
        #skillBar { display: flex; gap: 10px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 10px; border: 1px solid #444; }
        .skill-slot {
            width: 60px; height: 60px; background: #222; border: 2px solid #555; border-radius: 8px;
            display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; position: relative; transition: 0.2s;
        }
        .skill-slot.active { border-color: #ffd700; background: #444; }
        .skill-key { position: absolute; top: 2px; left: 2px; font-size: 10px; background: #fff; color: #000; width: 14px; height: 14px; border-radius: 50%; text-align: center; line-height: 14px; font-weight: bold; }
        .skill-icon { font-size: 18px; }
        .skill-name { font-size: 9px; font-weight: bold; text-transform: uppercase; }
        .skill-cost { font-size: 9px; color: #00ffff; }

        .floating-text {
            position: absolute; font-weight: bold; font-size: 16px; pointer-events: none;
            animation: floatUp 1.2s ease-out forwards; text-shadow: 1px 1px 0 #000; z-index: 100;
        }
        @keyframes floatUp { 0% { transform: translateY(0) scale(1); opacity: 1; } 100% { transform: translateY(-50px) scale(1.1); opacity: 0; } }

        #levelInfoBox {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            color: #ddd; font-size: 14px; background: rgba(0,0,0,0.5); padding: 5px 15px; border-radius: 20px;
        }

        #reloadContainer {
            position: absolute; 
            bottom: 120px; 
            left: 50%; transform: translateX(-50%);
            width: 60px; height: 6px; 
            background: #444; border: 1px solid #fff; border-radius: 3px;
            display: none; 
            pointer-events: none;
        }
        #reloadBar { width: 0%; height: 100%; background: #ffd700; transition: width 0.1s linear; }

    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas"></canvas>

    <div id="baseHealthContainer">
        <div id="baseHealthBar"></div>
        <div id="baseHealthText">HP Th√†nh: 1000/1000</div>
    </div>

    <div id="reloadContainer"><div id="reloadBar"></div></div>

    <div id="levelInfoBox">M√†n: <span id="lvlNum">1</span> - ƒê·ª£t: <span id="waveNum">1</span></div>

    <div id="centerNotification">
        <h1 id="levelTitle">LEVEL 1</h1>
        <h2 id="waveTitle">Wave 1 Start!</h2>
    </div>

    <div id="statsPanel" class="ui-panel">
        <h3 style="margin: 0 0 10px 0; border-bottom: 1px solid #555;">Ch·ªâ S·ªë (ƒê√£ C√¢n B·∫±ng)</h3>
        <div class="stat-row"><span>S√°t th∆∞∆°ng:</span> <span class="stat-val" id="dispDmg">0</span></div>
        <div class="stat-row"><span>Ch√≠ m·∫°ng:</span> <span class="stat-val" id="dispCritRate">0%</span></div>
        <div class="stat-row"><span>M√°u Th√†nh Max:</span> <span class="stat-val" id="dispMaxHp">1000</span></div>
        <hr style="border-color: #444;">
        <div class="stat-row"><span>S·ªë l∆∞·ª£ng t√™n:</span> <span class="stat-val special-stat" id="dispArrowCount">1</span></div>
        <div class="stat-row"><span>B·∫≠t n·∫£y:</span> <span class="stat-val special-stat" id="dispRicochet">Kh√¥ng</span></div>
    </div>

    <div id="resourcePanel" class="ui-panel">
        <div class="soul-label">Linh H·ªìn</div>
        <div class="soul-count" id="soulDisplay">0</div>
    </div>

    <div id="skillBarContainer">
        <div id="skillBar">
            <div class="skill-slot active" onclick="selectMode('normal')" id="skill1"><div class="skill-key">1</div><div class="skill-icon">üèπ</div><span class="skill-name">Th∆∞·ªùng</span><span class="skill-cost">0 Soul</span></div>
            <div class="skill-slot" onclick="selectMode('burn')" id="skill2"><div class="skill-key">2</div><div class="skill-icon">üî•</div><span class="skill-name">Thi√™u ƒê·ªët</span><span class="skill-cost" style="color:#ff4400">50 Soul</span></div>
            <div class="skill-slot" onclick="selectMode('lightning')" id="skill3"><div class="skill-key">3</div><div class="skill-icon">‚ö°</div><span class="skill-name">S√©t Gi·∫≠t</span><span class="skill-cost" style="color:#ffff00">30 Soul</span></div>
            <div class="skill-slot" onclick="selectMode('knockback')" id="skill4"><div class="skill-key">4</div><div class="skill-icon">üí®</div><span class="skill-name">ƒê·∫©y L√πi</span><span class="skill-cost" style="color:#00ffff">100 Soul</span></div>
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    /* --- GAME CONFIG & STATS --- */
    let gameActive = true;
    let souls = 50;
    let currentMode = 'normal';
    
    // RELOAD SYSTEM (0.5 GI√ÇY)
    let canShoot = true;
    let reloadTimer = 0;
    const RELOAD_TIME = 30; // <--- 30 Frames = 0.5 Gi√¢y (60fps)

    const GameSystem = {
        level: 1,
        wave: 1,
        totalWavesInLevel: 1,
        enemiesToSpawn: 0,
        enemiesSpawned: 0,
        spawnTimer: 0,
        spawnRate: 60,
        
        startLevel: function() {
            this.level++;
            this.wave = 0;
            this.totalWavesInLevel = Math.ceil(this.level / 3);
            this.startNextWave();
            showBigTitle(`LEVEL ${this.level}`, 2000);
        },

        startNextWave: function() {
            this.wave++;
            if (this.wave > this.totalWavesInLevel) {
                this.startLevel();
                return;
            }
            this.enemiesSpawned = 0;
            let baseMobs = 5 + Math.floor(this.level * 1.5);
            this.enemiesToSpawn = baseMobs;
            
            if (this.level % 5 === 0 && this.wave === this.totalWavesInLevel) {
                this.enemiesToSpawn = 1;
                showBigTitle(`‚ö†Ô∏è BOSS FIGHT ‚ö†Ô∏è`, 3000, true);
            } else {
                showBigTitle(`Wave ${this.wave}/${this.totalWavesInLevel}`, 1500);
            }
            this.spawnRate = Math.max(20, 80 - this.level * 2); 
            updateLevelInfo();
        }
    };

    const SKILLS = {
        normal: { cost: 0, color: '#fff' },
        burn: { cost: 50, color: '#ff4400', duration: 5, dmgPerSec: 5 },
        lightning: { cost: 30, color: '#ffff00', bonusDmg: 10, slowDuration: 3 },
        knockback: { cost: 100, color: '#00ffff', bonusDmg: 15, pushDist: 100 }
    };

    const playerStats = {
        damage: 25,
        critRate: 0.1, // 10%
        critDmg: 1.5,
        baseMaxHp: 1000,
        baseCurrentHp: 1000,
        arrowCount: 1,      
        canRicochet: false, 
        ricochetRange: 250
    };

    /* --- CLASSES --- */
    let arrows = [];
    class Arrow {
        constructor(x, y, velocity, angle, type, isBouncing = false) {
            this.x = x; this.y = y; this.velocity = velocity; this.angle = angle;
            this.type = type; this.active = true; this.radius = 4;
            this.isBouncing = isBouncing;
        }
        update() {
            this.x += Math.cos(this.angle) * this.velocity;
            this.y += Math.sin(this.angle) * this.velocity;
            if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.active = false;
        }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            ctx.fillStyle = SKILLS[this.type].color;
            ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 5); ctx.lineTo(-10, -5); ctx.fill();
            if (this.type !== 'normal') { ctx.shadowBlur = 10; ctx.shadowColor = ctx.fillStyle; }
            ctx.restore();
        }
    }

    let enemies = [];
    class Enemy {
        constructor(isBoss = false) {
            this.isBoss = isBoss;
            this.radius = isBoss ? 50 : (Math.random() * 10 + 15);
            this.x = Math.random() * (canvas.width - 60) + 30;
            this.y = -80;
            let hpMultiplier = Math.pow(1.1, GameSystem.level - 1);
            
            if (isBoss) {
                this.maxHp = 800 * hpMultiplier;
                this.baseSpeed = 0.3 + (Math.random() * 0.2);
            } else {
                this.maxHp = 40 * hpMultiplier;
                this.baseSpeed = (Math.random() * 1.5) + 0.5 + (GameSystem.level * 0.05); 
            }
            this.currentSpeed = this.baseSpeed;
            this.hp = this.maxHp;
            this.active = true;
            this.status = { burnTime: 0, burnTick: 0, slowTime: 0, isFrozen: false };
        }

        update() {
            if (this.status.burnTime > 0) {
                this.status.burnTick++;
                if (this.status.burnTick >= 60) {
                    this.takeDamage(SKILLS.burn.dmgPerSec * (1 + GameSystem.level*0.1), false, 'burn');
                    this.status.burnTime--;
                    this.status.burnTick = 0;
                }
            }
            if (this.status.slowTime > 0) {
                this.status.slowTime -= 1/60;
                this.currentSpeed = this.baseSpeed * 0.5;
                this.status.isFrozen = true;
            } else {
                this.currentSpeed = this.baseSpeed;
                this.status.isFrozen = false;
            }
            this.y += this.currentSpeed;
            if (this.y > canvas.height - 80) {
                this.active = false;
                let dmgToBase = this.isBoss ? 500 : 100;
                playerStats.baseCurrentHp -= dmgToBase;
                createFloatingText("-" + dmgToBase, this.x, this.y - 20, '#ff0000', true);
                updateUI();
                if (playerStats.baseCurrentHp <= 0) gameOver();
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            if (this.isBoss) ctx.fillStyle = '#9400D3';
            else if (this.status.isFrozen) ctx.fillStyle = '#ADD8E6';
            else if (this.status.burnTime > 0) ctx.fillStyle = '#ff6600';
            else ctx.fillStyle = '#66cc66';
            ctx.fill();
            if (this.isBoss) { ctx.lineWidth = 3; ctx.strokeStyle = '#fff'; ctx.stroke(); }
            const hpW = this.radius * 2;
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - hpW/2, this.y - this.radius - 10, hpW, 5);
            ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x - hpW/2, this.y - this.radius - 10, hpW * (this.hp / this.maxHp), 5);
        }

        takeDamage(amount, isCrit, type) {
            this.hp -= amount;
            let color = '#fff';
            if (type === 'burn') color = '#ff4400';
            if (type === 'lightning') color = '#ffff00';
            if (isCrit) { color = '#ffd700'; amount = Math.floor(amount); }
            createFloatingText(Math.floor(amount), this.x, this.y - 20, color, isCrit);
            if (this.hp <= 0) {
                this.active = false;
                let soulGain = this.isBoss ? 200 : Math.floor(5 + GameSystem.level);
                souls += soulGain;
                createFloatingText("+" + soulGain + " Soul", this.x, this.y, '#00ffff');
                dropItemSystem(this.x, this.y, this.isBoss);
                updateUI();
            }
        }

        applyStatus(type) {
            if (type === 'burn') { this.status.burnTime = SKILLS.burn.duration; createFloatingText("CH√ÅY!", this.x, this.y - 30, '#ff4400'); }
            if (type === 'lightning') { this.status.slowTime = SKILLS.lightning.slowDuration; createFloatingText("CH·∫¨M!", this.x, this.y - 30, '#ffff00'); }
            if (type === 'knockback') { 
                let push = SKILLS.knockback.pushDist;
                if (this.isBoss) push *= 0.1; 
                this.y -= push; 
                createFloatingText("ƒê·∫®Y!", this.x, this.y - 30, '#00ffff'); 
            }
        }
    }

    /* --- BALANCED DROP SYSTEM (C√¢n b·∫±ng l·∫°i) --- */
    function getRandom(min, max) {
        return Math.random() * (max - min) + min;
    }

    function dropItemSystem(x, y, isBoss) {
        if (isBoss) {
            const rand = Math.random();
            if (rand < 0.5) {
                playerStats.arrowCount++;
                createFloatingText("‚¨Ü ƒêA TI·ªÑN (+1 TIA)", x, y, '#ff00ff', true);
            } else {
                if (!playerStats.canRicochet) {
                    playerStats.canRicochet = true;
                    createFloatingText("üîÑ K√çCH HO·∫†T B·∫¨T N·∫¢Y", x, y, '#ff00ff', true);
                } else {
                    playerStats.damage += 20;
                    createFloatingText("‚¨Ü +20 DMG", x, y, '#ff00ff', true);
                }
            }
            return;
        }

        if (Math.random() < 0.25) {
            const type = Math.floor(Math.random() * 3);
            let minD, maxD, minC, maxC, minH, maxH;

            if (GameSystem.level <= 50) {
                minD = 1; maxD = 5;
                minC = 0.5; maxC = 2; 
                minH = 10; maxH = 100;
            } else {
                minD = 5; maxD = 10;
                minC = 2; maxC = 5; 
                minH = 100; maxH = 300;
            }

            if (type === 0) {
                let gain = Math.floor(getRandom(minD, maxD + 1)); 
                playerStats.damage += gain;
                createFloatingText(`‚öîÔ∏è +${gain} DMG`, x, y, '#ff4444', true);
            } 
            else if (type === 1) {
                let gainPercent = getRandom(minC, maxC);
                playerStats.critRate += (gainPercent / 100); 
                if(playerStats.critRate > 0.9) playerStats.critRate = 0.9;
                createFloatingText(`üéØ +${gainPercent.toFixed(1)}% CRIT`, x, y, '#ffd700', true);
            } 
            else {
                let hpGain = Math.floor(getRandom(minH, maxH + 1));
                playerStats.baseMaxHp += hpGain;
                playerStats.baseCurrentHp += hpGain;
                createFloatingText(`‚ù§Ô∏è +${hpGain} HP`, x, y, '#00ff00', true);
            }
        }
    }

    /* --- INPUT & RELOAD --- */
    const bow = { x: canvas.width / 2, y: canvas.height - 80, angle: -Math.PI/2, power: 0, charging: false };
    const mouse = { x: 0, y: 0 };
    canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; bow.angle = Math.atan2(mouse.y - bow.y, mouse.x - bow.x); });
    
    canvas.addEventListener('mousedown', () => { 
        if(gameActive && canShoot) bow.charging = true; 
    });
    
    canvas.addEventListener('mouseup', () => { 
        if(gameActive && bow.charging) { 
            fireArrow(); 
            bow.charging = false; 
            bow.power = 0; 
        } 
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === '1') selectMode('normal');
        if (e.key === '2') selectMode('burn');
        if (e.key === '3') selectMode('lightning');
        if (e.key === '4') selectMode('knockback');
    });

    function selectMode(mode) {
        currentMode = mode;
        document.querySelectorAll('.skill-slot').forEach(el => el.classList.remove('active'));
        let id = 'skill1';
        if(mode === 'burn') id = 'skill2';
        if(mode === 'lightning') id = 'skill3';
        if(mode === 'knockback') id = 'skill4';
        document.getElementById(id).classList.add('active');
    }

    function fireArrow() {
        if (!canShoot) return;

        const skill = SKILLS[currentMode];
        if (souls < skill.cost) { createFloatingText("Thi·∫øu Soul!", bow.x, bow.y - 60, '#aaa'); selectMode('normal'); return; }
        if (skill.cost > 0) { souls -= skill.cost; updateUI(); }

        const baseVelocity = (bow.power + 10) * 1.5;
        const count = playerStats.arrowCount;
        const spread = 0.1;
        let startAngle = bow.angle - ((count - 1) * spread) / 2;

        for (let i = 0; i < count; i++) {
            let angle = startAngle + i * spread;
            arrows.push(new Arrow(bow.x, bow.y, baseVelocity, angle, currentMode));
        }

        // K√çCH HO·∫†T RELOAD
        canShoot = false;
        reloadTimer = 0;
        document.getElementById('reloadContainer').style.display = 'block';
    }

    /* --- PHYSICS --- */
    function checkCollisions() {
        arrows.forEach(arrow => {
            if(!arrow.active) return;
            for (let enemy of enemies) {
                if(!enemy.active) continue;
                const dist = Math.hypot(arrow.x - enemy.x, arrow.y - enemy.y);
                if (dist < enemy.radius + arrow.radius) {
                    arrow.active = false;
                    let totalDmg = playerStats.damage;
                    let isCrit = Math.random() < playerStats.critRate;
                    if (isCrit) totalDmg *= playerStats.critDmg;
                    if (arrow.isBouncing) totalDmg *= 0.6; 

                    const skillInfo = SKILLS[arrow.type];
                    if (arrow.type === 'burn') enemy.applyStatus('burn');
                    else if (arrow.type === 'lightning') { totalDmg += skillInfo.bonusDmg; enemy.applyStatus('lightning'); }
                    else if (arrow.type === 'knockback') { totalDmg += skillInfo.bonusDmg; enemy.applyStatus('knockback'); }

                    enemy.takeDamage(totalDmg, isCrit, arrow.type);
                    if (playerStats.canRicochet && !arrow.isBouncing) triggerRicochet(arrow, enemy);
                    break; 
                }
            }
        });
    }

    function triggerRicochet(arrow, hitEnemy) {
        let closest = null; let minD = playerStats.ricochetRange;
        enemies.forEach(e => {
            if (e !== hitEnemy && e.active) {
                let d = Math.hypot(e.x - arrow.x, e.y - arrow.y);
                if (d < minD) { minD = d; closest = e; }
            }
        });
        if (closest) {
            let angle = Math.atan2(closest.y - arrow.y, closest.x - arrow.x);
            arrows.push(new Arrow(arrow.x, arrow.y, 18, angle, arrow.type, true));
        }
    }

    /* --- UI HELPERS --- */
    function showBigTitle(text, duration, isBoss = false) {
        const t1 = document.getElementById('levelTitle');
        const t2 = document.getElementById('waveTitle');
        t1.innerText = text;
        t1.style.display = 'block';
        t1.style.color = isBoss ? 'red' : '#ffd700';
        t2.innerText = isBoss ? "DI·ªÜT BOSS ƒê·ªÇ QUA M√ÄN!" : "Chu·∫©n b·ªã...";
        t2.style.display = 'block';
        setTimeout(() => { t1.style.display = 'none'; t2.style.display = 'none'; }, duration);
    }

    function updateLevelInfo() {
        document.getElementById('lvlNum').innerText = GameSystem.level;
        document.getElementById('waveNum').innerText = GameSystem.wave + "/" + GameSystem.totalWavesInLevel;
    }

    function updateUI() {
        document.getElementById('dispDmg').innerText = Math.floor(playerStats.damage);
        document.getElementById('dispCritRate').innerText = (playerStats.critRate * 100).toFixed(1) + '%';
        document.getElementById('dispMaxHp').innerText = Math.floor(playerStats.baseMaxHp);
        document.getElementById('dispArrowCount').innerText = playerStats.arrowCount;
        document.getElementById('dispRicochet').innerText = playerStats.canRicochet ? "C√≥" : "Kh√¥ng";
        document.getElementById('soulDisplay').innerText = souls;
        const hpPct = (playerStats.baseCurrentHp / playerStats.baseMaxHp) * 100;
        document.getElementById('baseHealthBar').style.width = Math.max(0, hpPct) + '%';
        document.getElementById('baseHealthText').innerText = `HP: ${Math.max(0, Math.floor(playerStats.baseCurrentHp))}/${Math.floor(playerStats.baseMaxHp)}`;
    }

    function createFloatingText(text, x, y, color, isBig=false) {
        const el = document.createElement('div');
        el.className = 'floating-text'; el.innerText = text;
        el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.color = color;
        if(isBig) { el.style.fontSize = '24px'; el.style.zIndex = 101; }
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 1200);
    }

    function gameOver() {
        gameActive = false;
        alert(`GAME OVER! B·∫°n ƒë√£ tr·ª• ƒë·∫øn M√†n ${GameSystem.level} - Wave ${GameSystem.wave}`);
        location.reload();
    }

    /* --- MAIN LOOP --- */
    GameSystem.enemiesToSpawn = 5;
    
    function animate() {
        if(!gameActive) return;
        ctx.clearRect(0,0,canvas.width, canvas.height);

        // RELOAD BAR LOGIC
        if (!canShoot) {
            reloadTimer++;
            const pct = (reloadTimer / RELOAD_TIME) * 100;
            document.getElementById('reloadBar').style.width = pct + '%';
            if (reloadTimer >= RELOAD_TIME) {
                canShoot = true;
                document.getElementById('reloadContainer').style.display = 'none';
            }
        }

        // DRAW BOW
        if(bow.charging && bow.power < 15) bow.power += 0.5;
        ctx.save(); ctx.translate(bow.x, bow.y); ctx.rotate(bow.angle);
        ctx.beginPath(); ctx.strokeStyle = canShoot ? '#fff' : '#555'; 
        const pull = bow.charging ? -bow.power * 2 : 0;
        ctx.moveTo(0, -30); ctx.quadraticCurveTo(pull, 0, 0, 30); ctx.stroke();
        ctx.beginPath(); ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 4;
        ctx.arc(0, 0, 30, Math.PI/2, -Math.PI/2, false); ctx.stroke();
        if(bow.charging) { ctx.fillStyle = SKILLS[currentMode].color; ctx.fillRect(pull, -2, 40, 4); }
        ctx.restore();

        // OBJECTS
        arrows.forEach(a => { a.update(); a.draw(); });
        arrows = arrows.filter(a => a.active);

        if (GameSystem.enemiesSpawned < GameSystem.enemiesToSpawn) {
            GameSystem.spawnTimer++;
            if (GameSystem.spawnTimer > GameSystem.spawnRate) {
                const isBoss = (GameSystem.level % 5 === 0 && GameSystem.wave === GameSystem.totalWavesInLevel && GameSystem.enemiesToSpawn === 1);
                enemies.push(new Enemy(isBoss));
                GameSystem.enemiesSpawned++;
                GameSystem.spawnTimer = 0;
            }
        } 
        else if (enemies.length === 0) {
            setTimeout(() => {
                if (enemies.length === 0 && GameSystem.enemiesSpawned >= GameSystem.enemiesToSpawn) {
                    GameSystem.startNextWave();
                }
            }, 1000);
        }

        enemies.forEach(e => { e.update(); e.draw(); });
        enemies = enemies.filter(e => e.active);

        checkCollisions();
        requestAnimationFrame(animate);
    }

    updateUI();
    animate();
    showBigTitle("LEVEL 1", 2000);
    window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; bow.x = canvas.width/2; bow.y = canvas.height - 80; });

</script>
</body>
</html>